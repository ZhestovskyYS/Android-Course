# Coroutines

<show-structure depth="3"/>

## Что такое корутина (сопрограмма)

Сопрограммы были впервые предложены Мелвином Конвеем (Melvin Conway) в 1963 году. В своей работе "Design of a Separable
Transition-diagram Compiler" Конвей описал идею сопрограмм как генерализации подпрограмм, которые могут приостанавливать
и возобновлять свое выполнение в определённых точках. Это отличалось от стандартных функций, которые имеют единственную
точку входа и выхода.

Сопрограмма — это функция, которая может приостанавливать свое выполнение и возвращать управление вызывающему коду,
сохраняя при этом свое состояние для последующего возобновления. Ключевые моменты:

- **Множественные точки входа и выхода**: В отличие от обычных функций, сопрограммы могут входить и выходить из
  выполнения в нескольких местах с помощью специальных инструкций.

- **Сохранение контекста**: При приостановке выполнения сохраняется текущий контекст сопрограммы, включая значения
  локальных переменных и позицию в коде.

- **Явная передача управления**: Управление между сопрограммами передается явно, что позволяет разработчику
  контролировать последовательность выполнения.

### Проблемы, решаемые сопрограммами:

- **Кооперативная многозадачность**: Сопрограммы позволяют различным частям программы выполняться по очереди, передавая
  управление друг другу без необходимости в потоках или прерываниях.

- **Асинхронное программирование**: Они упрощают работу с асинхронными операциями, такими как ввод-вывод, позволяя
  писать
  код в более линейном и понятном стиле.

- **Сохранение состояния между вызовами**: Сопрограммы могут сохранять свое состояние между вызовами, что облегчает
  реализацию генераторов, итераторов и конечных автоматов.

- **Улучшение производительности**: За счёт уменьшения накладных расходов на переключение контекста по сравнению с
  потоками,
  сопрограммы могут быть более эффективными в некоторых сценариях.

### Только ли Kotlin имеет реализацию сопрограмм?

{id="kotlin_only"}

Конечно нет, однако идентичных реализаций нет. Среди языков, которые имеют реализацию сопрограмм в том или ином виде:

- **Python, C#, C++ (20+), JavaScript, Rust, Swift, Dart, Visual Basic .NET, Nim**: поддерживают ключевые функции
  _**async / await**_, некоторые предоставляют расширенный набор методов, например _**yield**_
- **Lua, Ruby (Fiber), Go, Delphi, Erlang & Elixir, Lisp, F#, PHP, Tcl, Haskell, Julia, Perl, Crystal, Racket**: имеют
  собственные идиоматические реализации с соблюдением общей концепции сопрограмм

Реализации, кроме всего прочего, отличаются и уровнем интеграции в язык. Где-то это часть стандартной библиотеки и
синтаксиса языка, но чаще все же это отдельно развиваемые библиотеки, прочно закрепившиеся в экосистеме общего стека
языка.

## Ключевые концепции корутин

Как было сказано выше, есть три основные фичи: **множественные точки входа и выхода**, **сохранение контекста**, **явная
передача управления**.

Чтобы все это работало, в реализации сопрограмм для языка программирования должно быть:

1. Способ пометить точки, в которых выполнение инструкций может быть безопасно приостановлено и вскоре возобновлено

2. Набор примитивов, которые позволят оборачивать контекст выполнения, для сохранения прогресса выполнения инструкций
   между точками приостановки

3. Механизм передачи и сохранения примитивов контекста выполнения

4. Позволяющий вернуть контроль над занятым выполнением инструкций потоку, который инициировал запуск
   сопрограммы, механизм. Он же должен предоставить иной поток для возобновления выполнения инструкций

5. Механизм менеджмента потоков, позволяющий эффективно переключать выполнения сопрограмм

## Реализация сопрограмм в Kotlin

{id="kotlin-realisation"}

Корутины в Kotlin появились во время выпуска версии Kotlin v1.3 в 2018 году в виде библиотеки `kotlinx.coroutines`.
Реализация корутин в Kotlin наиболее похожа на таковую в Goroutines языка Go. С помощью этой библиотеки становится
возможным писать асинхронный код в том же стиле и виде, что и обычный. Все дополнительные настройки производятся за счет
кодогенерации.

Вот пример как будет выглядеть код:

```kotlin
override suspend fun loadChooseCardScreenData(): ChooseLuckyCardScreenEntity =
        withContext(dispatchers.io) {
            Log.d("Calling cloud function", CLOUD_FUNC_REQUEST_LUCKY_CARD_DECK)
            val response = ParseCloud.callFunction<Map<String, Any>?>(
                CLOUD_FUNC_REQUEST_LUCKY_CARD_DECK, HashMap<String, Any>()
            )?.toModel<ChooseLuckyCardScreenEntity>()
                ?: ChooseLuckyCardScreenEntity()
            return@withContext response
        }
```

{ collapsible="true" collapsed-title="Функция `loadChooseCardScreenData`"}

после декомпиляции:

```kotlin
   @Nullable
   public Object loadChooseCardScreenData(@NotNull Continuation $completion) {
      return BuildersKt.withContext((CoroutineContext)this.dispatchers.getIo(), (Function2)(new Function2((Continuation)null) {
         int label;

         public final Object invokeSuspend(Object var1) {
            Object var9 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
            switch (this.label) {
               case 0:
                  ChooseLuckyCardScreenEntity var10000;
                  label17: {
                     ResultKt.throwOnFailure(var1);
                     Log.d("Calling cloud function", "requestLuckyCardDeck");
                     Map var3 = (Map)ParseCloud.callFunction("requestLuckyCardDeck", (Map)(new HashMap()));
                     if (var3 != null) {
                        Map $this$toModel$iv = var3;
                        int $i$f$toModel = false;
                        String var7 = (new JSONObject($this$toModel$iv)).toString();
                        Intrinsics.checkNotNullExpressionValue(var7, "toString(...)");
                        String jsonString$iv = var7;
                        ChooseLuckyCardScreenEntity var4 = (ChooseLuckyCardScreenEntity)(new Gson()).fromJson(jsonString$iv, ChooseLuckyCardScreenEntity.class);
                        if (var4 != null) {
                           var10000 = var4;
                           break label17;
                        }
                     }

                     var10000 = new ChooseLuckyCardScreenEntity((TarotCard)null, (List)null, (String)null, (Integer)null, (Integer)null, (Integer)null, 63, (DefaultConstructorMarker)null);
                  }

                  ChooseLuckyCardScreenEntity response = var10000;
                  return response;
               default:
                  throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
            }
         }

         public final Continuation create(Object value, Continuation $completion) {
            return (Continuation)(new <anonymous constructor>($completion));
         }

         public final Object invoke(CoroutineScope p1, Continuation p2) {
            return ((<undefinedtype>)this.create(p1, p2)).invokeSuspend(Unit.INSTANCE);
         }

         // $FF: synthetic method
         // $FF: bridge method
         public Object invoke(Object p1, Object p2) {
            return this.invoke((CoroutineScope)p1, (Continuation)p2);
         }
      }), $completion);
   }
```

{ collapsible="true" collapsed-title="Декомпилированная функция `loadChooseCardScreenData`"}

Как видно из последнего блока с кодом, после компиляции из кода уходит слово suspend, вместо него появляется аргумент
`@NotNull Continuation $completion`. Также появилась переменная `label` и метка `label17`. Они нужны для переключения
выполнения: переменная - чтобы переключить выполнение после возобновления корутины, а метка - для быстрого возврата
выполнения после завершения блока инструкций. Получается некого рода стейт машина, которая переключается между
предопределенными состояниями процесса выполнения инструкций.

Рассмотрим концепции, перечисленные в предыдущем разделе:

- **Точками приостановки и возобновления** считается место вызова **_suspend_** функции в запущенной корутине

- **Примитивы для сохранения контекста выполнения** - это _**Continuation**_, он отвечает
  за сохранение прогресса выполнения и возобновление/остановку корутины, тем самым отвечая и на пункт 3 (**механизм
  передачи и сохранения примитивов контекста выполнения**)

- _**Continuation**_ в купе с _**CoroutineContext**_ и _**Dispatcher**_ участвуют в механизме **менеджмента потоков**,
  доступных корутинам и переключения выполнения инструкций между ними.

### Как запустить корутину

Для запуска корутины нужно использовать один из билдеров корутин:

- **_runBlocking_**:
    - Редко используемый билдер, так как лишает корутину ее главного преимущества (не блокирования
      потоков выполнения), но позволяет дождаться окончания асинхронной работы и получить ее результат на месте
    - Использует свой собственный **`Dispatcher`**

> Стоит использовать только если вы на 100% уверены в том что делаете.
> { style="warning"}

- **_launch_**
    - Самый часто используемый билдер
    - Является расширением **`CoroutineScope`** и берет контекст из него (если переданный в
      аргумент контекст пустой) или из первого аргумента
    - Запускает параллельную корутину и возвращает объект **`Job`**, с помощью которого можно следить за жизненным
      циклом
      корутины, дождаться ее выполнения в другой корутине (при помощи метода **`join`**), и отменить с помощью метода
      **`cancel`**
    - По умолчания корутина стартует сразу после инициализации, но можно изменить это, передав аргумент
      **`start: CoroutineStart`**

- **_withContext_**
    - Билдер для переключения **`CoroutineContext`** вложенной в него корутины
    - В отличие от **`launch`** запускает переданный блок последовательно, относительно родительской корутины
    - Есть оптимизации для случаев, когда контекст вовсе не изменился или изменилось все, кроме **`Dispatcher`**-а

- **_async_**
    - Идентичен билдеру **`launch`**, за исключением возвращаемого объекта класса **`Deffered`**
    - **`Deffered`** является расширенным интерфейсом **`Job`** и имеет метод **`await`**, который позволяет дождаться
      результата работы корутины
    - Есть расширение **`awaitAll`** для коллекций **`Deffered`**, которое позволяет дождаться всех корутин, запущенных
      билдером **`async`**

- **_coroutineScope_**
    - билдер для группировки корутин в скоуп, создания созависимого уровня иерархии, где падение единственной корутины
      закроет
      все прочие в этом скоупе
    - наследует `Job` от родительской корутины и может быть запущен только из уже ранее запущенной корутины
    - скоуп возвращает результат работы переданного ему блока

- **_supervisorScope_**
    - идентичный **`coroutineScope`** билдер, за исключением измененного поведения - при падении какой-либо внутренней
      корутины скоуп не будет завершен

### CoroutineContext

Класс для переноса общей конфигурации корутин между вглубь общей иерархии. Он состоит их `CoroutineContext.Element`-ов,
которые в свою очередь сами являются контекстом. Весь фокус в том, чтобы объединять все элементы не в словарь `[Map]`, а
при помощи паттерна _компоновщик_. Хотя для пользователей библиотеки это может быть не очевидно, да и в конечном счете
это не столь важно для внешнего пользователя.

Вы вольны добавлять собственные элементы контекста, имплементируя интерфейс **`CoroutineContext.Element`**. Основные
элементы контекста:

- **Job**: отвечает за жизненный цикл корутины - проверку его состояния и его контроль

- **Dispatcher**: отвечает за диспетчеризацию корутин между потоками

- **CoroutineExceptionHandler**: помогает отслеживать исключения, но не предотвращает их как то делает `try - catch`
  блок

- **CoroutineName**: переопределяет имя корутины, что полезно при отладке или аналитике

### Управление потоками

Для управления потоками, на которых запускаются корутины в **`kotlinx.coroutines`** есть класс **`Dispatcher`**.
**`Dispatcher`** также является частью **`CoroutineContext`**, благодаря чему передается вглубь иерархии корутин.

Назначение **`Dispatcher`** - предоставление корутинам потоков в моменты их возобновления. Для этого у **`Dispatcher`**
есть определенный пул потоков. В самом простом сценарии диспетчер просто выдает новый поток каждой новой корутине. Но
так как корутина способна рано или поздно прекращать свое выполнение и даже приостанавливаться, то потоки
переиспользуются и добавляются по мере роста количества активных корутин. И, наоборот, когда нагрузка спадает и
длительное время не растет, то пул потоков может быть высвобожден.

Кроме того, стоит помнить, что одно приложение не должно использовать все доступные ресурсы процессора, так как
пользователь редко обходится использованием лишь одного приложения за раз. Да и более того, система сама запускает
служебные приложения для обеспечения работы базовых функций системы (лаунчер, часы, сервисы-демоны и т.д)

Есть предопределенные диспетчеры, доступные через объект **`Dispatchers`**

#### Default

- Основной диспетчер, используемый, если не определен иной
- Максимальное количество потоков в пуле по умолчанию равно либо 64, либо количеству доступных процессорных ядер, в
  зависимости от того, что больше
- Предназначен для интенсивных неблокирующих операций, например сложных интегральных вычислений

#### IO

- Диспетчер для блокирующих операций ввода/вывода
- Максимальное количество потоков в пуле по умолчанию равно количеству доступных процессорных ядер, но всегда не менее
  двух
- Делит пул потоков с **Default**, но при этом не исчерпывает его

#### Main & Main.immediate

- На всех платформах, кроме _Android_, необходимо создать реализацию вручную
- Обладает пулом из единственного потока, на котором запущенно приложение
- Следует относиться к нему бережно, стараясь не нагружать интенсивными или блокирующими операциями
- **Main.immediate** нужен для использования в билдере **`withContext`**, чтобы исключить лишнюю диспетчеризацию при
  запуске корутины на главном потоке

#### Unconfined

- Единственный диспетчер без пула потоков
- Создан для случаев, когда корутине не нужна лишняя диспетчеризация и она может выполняться на любом потоке
- С этим диспетчером корутина запускается и возобновляется на актуальном потоке

> Редко используется, но может быть полезен:
> - для тестов, когда нужно оставить ответственность по диспетчеризации тестируемому коду
> - когда нужно сэкономить на диспетчеризации корутины, ответственность за переключение потоков мы берем на себя.
    Таким образом, он моментально запускает выполнение операции
> - когда мы используем собственную систему потоков и не хотим передавать ответственность **`Dispathcer`**-ам
>
{style="note"}

<seealso>
    <category ref="src">
        <a href="https://kt.academy/article/cc-dispatchers">Kotlin Academy | Kotlin Coroutines dispatchers</a>
    </category>
</seealso>