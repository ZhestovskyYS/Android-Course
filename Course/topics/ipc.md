# IPC

<secondary-label ref="wip"/>

Каждое приложение в Android выполняется в своей собственной "песочнице" (Application Sandbox).
Механизм "песочницы" в Android основан на присвоении каждому приложению уникального **user ID (UID)** и **group ID (GID)
**,
таким образом каждому приложению соответствует свой уникальный непривилегированный пользователь.
В то же время владельцам всех критических ресурсов системы являются более привилегированные пользователи,
имена и идентификаторы которых жестко зашиты в систему (см.
*[system/core/include/private/android\_filesystem\_config.h](https://android.googlesource.com/platform/system/core//+/android-4.2.2_r1.2/include/private/android_filesystem_config.h)*).
Системные сервисы, которые запускаются от имени этих пользователей, имеют доступ к соответствующим критическим ресурсам
системы (например, к GPS данным), в то время как процессы обычных приложений доступ к этим ресурсам получить не могут.

Однако приложения должны иметь возможность «попросить» системные сервисы предоставить им такую информацию, а последние,
в свою очередь, должны иметь возможность предоставить такую информацию приложениям. Так как приложения и системные
сервисы исполняются в разных процессах, то для организации такого обмена операционной системе необходимо предоставить
механизм обмена информацией между процессами. Более того, даже обычные приложения иногда должны взаимодействовать друг с
другом. Например, почтовый клиент может «попросить» просмотрщик изображений отобразить графическое приложение к письму.

В Android обмен сигналами и данными между процессами организован с помощью фреймворка межпроцессного взаимодействия (
Inter-Process Communication) **Binder**. Стандартный *System V IPC*
фреймворк [не поддерживается](https://android.googlesource.com/platform/ndk/+/android-4.2.2_r1.2/docs/system/libc/SYSV-IPC.html)
данной операционной системой, в частности, в **Bionic libc** отсутствуют заголовочные файлы <sys/ipc.h>, <sys/sem.h>, <
sys/shm.h>, <sys/msg.h>. В некоторых специфических случаях (например, для взаимодействия с демоном Zygote) используются
**Unix domain sockets**. Все остальные способы взаимодействия между процессами, включая Intents, реализованы используя
Binder IPC. Этот фреймворк позволяет синхронно и асинхронно вызывать методы удаленных объектов так, будто они локальные,
обмениваться файловыми дескрипторами между процессами, **link to death** (автоматическое оповещение в случае если Binder
определенного процесса был прерван), и т.д.

### Как работает Binder IPC?

Взаимодействие между процессами организовано по синхронной клиент-серверной модели. Клиент инициирует соединение и ждет
ответа со стороны сервера. Таким образом, взаимодействие между клиентом и сервером происходит последовательно. Такой
дизайн позволяет разработчику вызывать удаленные методы словно они находятся в том же самом процессе. Стоит отметить,
что это не расходится с тем, что я писал выше по поводу асинхронного вызова методов: в случае асинхронного вызова,
сервер сразу же возвращает пустой ответ клиенту.

Схема взаимодействия процессов через Binder представлена на рисунке. 
Приложение (клиент) выполняется в процессе *Process A*, получает доступ к функциональности,
реализованной в сервисе, который выполняется в процессе *Process B*.

![](236e4b55544aa9a4485acb60d8c5460a.png)

## Полезные видео

> Промежуток `[27:44 - 37:05]`



> Можно смотреть целиком



<seealso>
  <category ref="src">
    <a href="https://developer.android.com/guide/platform">Android Developers | Platform architecture</a>
    <a href="https://nurlandroid.com/?p=321#:~:text=Zygote%20—%20ключевой%20компонент%20любой%20Android,%2Fsystem%2Fbin%2Fapp_process">Процесс загрузки ОС Андроид - Nurlandroid</a>
  </category>
    <category ref="related">
        <a href="https://habr.com/ru/articles/176093/">Основы безопасности операционной системы Android. Безопасность на уровне Application Framework. Binder IPC</a>
        <video src="https://youtu.be/4Mkrk3YDuCw"/>
        <video src="https://youtu.be/yyaw0C6oA5k" />
    </category>
</seealso>
