# ОС Android

## Архитектура платформы

**Android** - это программный стек на базе Linux с открытым исходным кодом, созданный для широкого спектра устройств и
форм-факторов

![architecture](The Android software stack.png)

### Ядро

Модифицированное разработчиками компании Google ядро операционной системы Linux.
Google внесла существенные модификации, адаптировав его для мобильных устройств.
Основные компоненты ядра Android:

**Binder IPC**

Этот механизм межпроцессного взаимодействия заменяет традиционные IPC Linux (например, сокеты или сигналы). Binder оптимизирован для быстрого обмена данными между процессами, что критично для работы
сервисов Android (например, уведомлений или системных приложений). Он также обеспечивает контроль прав доступа через UID/GID.

**Специфичные драйверы и подсистемы**

- _Ashmem (Anonymous Shared Memory)_: Управляет общей памятью между процессами, поддерживая «закрепление» областей памяти для предотвращения их удаления.
- _Logger_: Логирование системных событий (например, журналы приложений).
- _Wakelocks_: Контроль энергопотребления. Позволяют приложениям временно запретить переход устройства в спящий режим.
- _Low Memory Killer (LMK)_: Убивает фоновые процессы при нехватке памяти, предотвращая зависания. Работает совместно с kswapd — демоном, освобождающим память через сброс кэша.

**Generic Kernel Image (GKI)**

С версии Android 12 Google внедрила GKI, разделив ядро на:

- _Универсальную часть (Generic Core)_: Общая для всех устройств, обновляется через Google Play.
- _Вендорные модули_: Аппаратно-зависимые драйверы (например, для Qualcomm или Exynos), поставляемые производителями.

Интерфейс _KMI (Kernel Module Interface)_ гарантирует совместимость модулей с разными версиями GKI. Это снижает фрагментацию и упрощает обновления.

**Безопасность**

- _SELinux_: Реализует Mandatory Access Control (MAC), ограничивая права процессов даже с root-доступом.
- _DM-verity_: Защищает целостность системных разделов от модификации.
- _IPC-изоляция_: Binder и другие механизмы проверяют права доступа к ресурсам.

**Управление энергопотреблением**

- _Power Management Wakelocks_: Контролируют, какие процессы могут удерживать устройство активным.
- _Runtime Power Management_: Динамически отключает неиспользуемые компоненты (например, ядра CPU).

### Hardware abstraction layer (HAL - уровень аппартаной абстракции )

Уровень аппаратной абстракции предоставляет интерфейс для взаимодействия с аппаратной частью устройства для более
высокоуровневой [платформы Java API](#java-api). HAL состоит из нескольких библиотечных модулей, каждый из которых
реализует
интерфейс для определенного типа аппаратного компонента. Когда платформа выполняет вызов для доступа к оборудованию
устройства, система Android загружает библиотечный модуль для этого аппаратного компонента.

### Android runtime

Для устройств под управлением Android версии 5.0 (уровень API 21) или выше каждое приложение запускается в собственном
процессе и со своим экземпляром Android Runtime (ART). ART написан для запуска нескольких виртуальных машин на
устройствах с низким объемом памяти путем выполнения файлов Dalvik Executable format (DEX), формата байт-кода,
разработанного специально для Android и оптимизированного для минимального объема памяти. Инструменты сборки, такие как
d8, компилируют исходные тексты Java в байт-код DEX, который может выполняться на платформе Android.

Некоторые из основных функций ART включают следующее:

- Компиляция с опережением времени (AOT) и точно в срок (JIT)
- Оптимизированная сборка мусора (GC)
- На Android 9 (уровень API 28) и выше преобразование файлов DEX пакета приложения в более компактный машинный код
- Улучшенная поддержка отладки, включая специальный профилировщик выборки, подробные диагностические исключения и отчеты
  о сбоях, а также возможность устанавливать контрольные точки для мониторинга определенных полей.

До Android версии 5.0 (уровень API 21) Dalvik был средой выполнения Android. Если ваше приложение хорошо работает на
ART, то оно может работать и на Dalvik, но обратное может быть неверным.

Android также включает набор основных библиотек среды выполнения, которые обеспечивают большую часть функциональности
языка программирования Java. В том числе
некоторые [возможности языка Java 8](https://developer.android.com/guide/platform/j8-jack), которые
использует [платформа Java](#java-api).

### Нативные C/C++ библиотеки

Доступ к ним предоставляется через JNI обертки, например в библиотеке [для платформы Java](#java-api) для работы
с [OpenGL ES](https://developer.android.com/develop/ui/views/graphics/opengl/about-opengl), или напрямую в
составе [Android NDK](https://developer.android.com/ndk)

### Платформа Java API { id="java-api"}

Java API Framework — это слой, предоставляющий готовые строительные блоки для разработки приложений.
Он включает набор классов и интерфейсов, которые абстрагируют низкоуровневые операции и упрощают
взаимодействие с системой. Вот его основные составляющие:

**Activity Manager**

Управляет жизненным циклом приложений и навигацией между экранами (Activity).
Отвечает за:

- Создание/уничтожение Activity.
- Стек навигации (back stack).
- Координацию процессов (например, запуск Activity из другого приложения).

> Пример: startActivity(), finish().

**Window Manager**

Контролирует окна и поверхности отрисовки. Взаимодействует с системным композитором (SurfaceFlinger) для:

- Распределения слоев интерфейса
- Обработки мультиоконного режима (split-screen, PiP)
- Управления размерами и позицией окон

**Content Providers**

Обеспечивают обмен данными между приложениями через стандартизированные URI. Примеры использования:

- Доступ к контактам, календарю, медиафайлам.
- Совместное использование БД или файлов.

Ключевые классы: ContentResolver, Cursor.

**View System**

Базовые элементы интерфейса:

- Виджеты: Button, TextView, RecyclerView.
- Макеты: XML-файлы (например, ConstraintLayout).
- Обработка событий: клики, жесты, анимации.
- Особенность: Декларативный подход через XML + программное управление.

**Resource Manager**

Управляет ресурсами приложения (строки, изображения, стили):

- Локализация: загрузка строк для разных языков.
- Адаптация под конфигурации (ночная тема, ориентация экрана).

Доступ через класс R.java (например, `R.string.app_name`).

**Notification Manager**

Работа с уведомлениями:

- Создание каналов уведомлений (Android 8+).
- Настройка приоритета, звука, вибрации.
- Группировка и отложенные действия (кнопки в уведомлениях).

Класс: NotificationCompat.Builder.

**Location Manager**

Доступ к геолокации:

- GPS, сетевые провайдеры (Wi-Fi, соты).
- Фоновое отслеживание (через FusedLocationProviderClient).
- Энергоэффективные режимы (например, геозоны).

**Telephony Manager**

Работа с мобильной связью:

- Информация о SIM-карте, операторе
- Отправка SMS/MMS (через SmsManager)
- Мониторинг состояния сети (роуминг, уровень сигнала)

**Package Manager**

Управление установленными приложениями:

- Получение метаданных (версия, разрешения)
- Запуск компонентов других приложений (через implicit intents)
- Проверка наличия функций устройства (например, камеры)

## Процесс загрузки

На картинке ниже представлен краткий процесс загрузки ОС Android. Но как видно на картинке, процесс останавливается на
запуске Launcher-а. Мы же пройдем весь процесс, вплоть до запуска обычного приложения.

![схема сущностей, участвующих в загрузке ОС](androidbootprocess.png)

### Этап 1. Bootrom

_Bootrom_ — это небольшой кусочек защищенной от записи флеш-памяти, встроенный в процессорный чип. Он содержит самый
первый код, который выполняется процессором при его включении. Далее, он запускает BootLoader.

### Этап 2. BootLoader

BootLoader выполняет первичный запуск специфичных настроек перед запуском ядра. То есть дословно, копирует файлы в
рабочую память устройства и передает управление коду, расположенному в разделе boot, что по сути есть ядро Linux.

### Этап 3. Ядро

Ядро запускает настройку кэша, защищенную память, планировщик задач и загружает драйверы. Когда ядро завершит настройку
и запуск своих подсистем, он первым делом запустить корневой и самый главный процесс **init().** Все процессы
запускаемые после него являются дочерними.

### Этап 4. init()

Процесс **init()** подключает директории /sys, /dev, /proc и запускает службы(daemon), которые указаны в файле **init.rc
**. Например, Service Manager, Media Server. Формат **init.rc** достаточно простой и по сути представляет собой набор
команд, разделенных на блоки. Каждый блок определяет стадию загрузки или, выражаясь языком разработчиков Android,
действие. И наконец **init()** доходит до запуска **среды выполнения Android** путем запуска службы **Zygote**.

### Этап 5. Среда выполнения Android

**Zygote** — ключевой компонент любой Android-системы, который ответственен за инициализацию, старт системных служб,
запуск и остановку пользовательских приложений и многие другие задачи. **Zygote** запускается с помощью небольшого
приложения **/system/bin/app\_process**. Задача **app\_proccess** — запустить виртуальную машину **Art/Dalvik**, код
которой располагается в разделяемой библиотекеё, а затем поверх нее запустить **Zygote**.

Когда все это будет сделано и **Zygote** получит управление, он начинает формирование среды исполнения Java-приложений с
помощью загрузки всех Java-классов фреймворка (сейчас их более 2000).

### Этап 6. system\_server

Затем **Zygote** запускает **system\_server**, включающий в себя большинство высокоуровневых (написанных на Java)
системных сервисов, в том числе **Window Manager**, **Status Bar**, **Package Manager** и, что самое важное, **Activity
Manager**, который в будущем будет ответственен за получение сигналов о старте и завершении приложений.

### Этап 7. Activity Manager

После этого **Zygote** открывает сокет **/dev/socket/zygote** и уходит в сон, ожидая данные. В это время запущенный
ранее **Activity Manager** посылает широковещательный интент **Intent.CATEGORY\_HOME**, чтобы найти *
*Launcher-приложение**, отвечающее за формирование рабочего стола, и отдает его имя **Zygote** через сокет. **Zygote**,
в свою очередь, форкается и запускает **Launcher-приложение** поверх виртуальной машины. Вуаля, у нас на экране
появляется рабочий стол, найденный **Activity Manager** и запущенный **Zygote**, и статусная строка, запущенная
system\_server в рамках службы **Status Bar**.

### Этап 8. Запуск «своего» приложения

После тапа по иконке искомого приложения **Launcher-приложение** пошлет интент с именем этого приложения, его примет
**Activity Manager** и передаст команду на старт приложения демону **Zygote.**

Когда **Zygote** получает запрос на старт приложения от **Activity Manager**, он не запускает новую виртуальную машину,
а просто **форкается**, то есть копирует самого себя и затем запускает поверх полученной **копии виртуальной машины**
нужное приложение.  **Копия ART/Dalvik VM**
создаёт [главный поток приложения(MainThread)](https://nurlandroid.com/?p=240).

<seealso>
  <category ref="src">
    <a href="https://developer.android.com/guide/platform">Android Developers | Platform architecture</a>
    <a href="https://nurlandroid.com/?p=321#:~:text=Zygote%20—%20ключевой%20компонент%20любой%20Android,%2Fsystem%2Fbin%2Fapp_process">Процесс загрузки ОС Андроид - Nurlandroid</a>
  </category>
</seealso>