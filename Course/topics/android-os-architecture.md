# ОС Android

## Архитектура платформы

**Android** - это программный стек на базе Linux с открытым исходным кодом, созданный для широкого спектра устройств и
форм-факторов

![architecture](The Android software stack.png)

### Ядро

Модифицированное разработчиками компании Google ядро операционной системы Linux.
Первая вариация ядра - [Dalvik](https://en.wikipedia.org/wiki/Dalvik_(software)) прослужила с 2003 по 2013 год.
Вторая вариация - [ART (**A**ndroid **R**unt**t**ime)](https://developer.android.com/guide/platform#art) заменила
предшевственника в 2014 и используется по сей день.

> Виртуальная машина Dalvik (DVM) - это виртуальная машина Android, оптимизированная для мобильных устройств. Она
> оптимизирует объем памяти, время автономной работы и производительность виртуальной машины. Java-коды сначала
> компилируются в байт-код (.class), как и в JVM. Dalvik VM интерпретирует этот скомпилированный код и преобразует его в
> исполняемые файлы (.dex — dalvik executable), подходящие для вашего телефона.

### Hardware abstraction layer (HAL - уровень аппартаной абстракции )

Уровень аппаратной абстракции предоставляет интерфейс для взаимодействия с аппаратной частью устройства для более
высокоуровневой [платформы Java API](#java-api). HAL состоит из нескольких библиотечных модулей, каждый из которых
реализует
интерфейс для определенного типа аппаратного компонента. Когда платформа выполняет вызов для доступа к оборудованию
устройства, система Android загружает библиотечный модуль для этого аппаратного компонента.

### Android runtime

Для устройств под управлением Android версии 5.0 (уровень API 21) или выше каждое приложение запускается в собственном
процессе и со своим экземпляром Android Runtime (ART). ART написан для запуска нескольких виртуальных машин на
устройствах с низким объемом памяти путем выполнения файлов Dalvik Executable format (DEX), формата байт-кода,
разработанного специально для Android и оптимизированного для минимального объема памяти. Инструменты сборки, такие как
d8, компилируют исходные тексты Java в байт-код DEX, который может выполняться на платформе Android.

Некоторые из основных функций ART включают следующее:

- Компиляция с опережением времени (AOT) и точно в срок (JIT)
- Оптимизированная сборка мусора (GC)
- На Android 9 (уровень API 28) и выше преобразование файлов DEX пакета приложения в более компактный машинный код
- Улучшенная поддержка отладки, включая специальный профилировщик выборки, подробные диагностические исключения и отчеты
  о сбоях, а также возможность устанавливать контрольные точки для мониторинга определенных полей.

До Android версии 5.0 (уровень API 21) Dalvik был средой выполнения Android. Если ваше приложение хорошо работает на
ART, то оно может работать и на Dalvik, но обратное может быть неверным.

Android также включает набор основных библиотек среды выполнения, которые обеспечивают большую часть функциональности
языка программирования Java, включая
некоторые [возможности языка Java 8](https://developer.android.com/guide/platform/j8-jack), которые
использует [платформа
Java](#java-api).

### Нативные C/C++ библиотеки

Доступ к ним предоставляется через JNI обертки, например в библиотеке [для платформы Java](#java-api) для работы
с [OpenGL ES](https://developer.android.com/develop/ui/views/graphics/opengl/about-opengl), или напрямую в
составе [Android NDK](https://developer.android.com/ndk)

### Платформа Java API { id="java-api"}

Весь набор функций ОС Android доступен вам через API, написанные на языке Java. Эти API формируют строительные блоки,
необходимые для создания приложений Android, упрощая повторное использование основных компонентов модульной системы и
сервисов, которые включают следующее:

- Богатую и расширяемую систему просмотра можно использовать для создания пользовательского интерфейса приложения,
  включая списки, сетки, текстовые поля, кнопки и даже встраиваемый веб-браузер
- Менеджер ресурсов, обеспечивающий доступ к ресурсам, не связанным с кодом, таким как локализованные строки, графика и
  файлы макетов
- Менеджер уведомлений, который позволяет всем приложениям отображать пользовательские оповещения в строке состояния
- Диспетчер действий, который управляет жизненным циклом приложений и обеспечивает общий стек обратной навигации
- Контент-провайдеры, которые позволяют приложениям получать доступ к данным из других приложений, таких как
  приложение "Контакты", или делиться своими собственными данными

Разработчики имеют полный доступ к тем же API-интерфейсам Framework, которые используют системные приложения Android.

## Процесс загрцзки

На картинке ниже представлен краткий процесс загрузки ОС Android. Но как видно на картинке, процесс останавливается на
запуске Launcher-а. Мы же пройдем весь процесс, вплоть до запуска обычного приложения.

![схема сущностей, участвующих в загрузке ОС](androidbootprocess.png)

### Этап 1. Bootrom

_Bootrom_ — это небольшой кусочек защищенной от записи флеш-памяти, встроенный в процессорный чип. Он содержит самый
первый код, который выполняется процессором при его включении. Далее, он запускает BootLoader.

### Этап 2. BootLoader

BootLoader выполняет первичный запуск специфичных настроек перед запуском ядра. То есть дословно, копирует файлы в
рабочую память устройства и передает управление коду, расположенному в разделе boot, что по сути есть ядро Linux.

### Этап 3. Ядро

Ядро запускает настройку кэша, защищенную память, планировщик задач и загружает драйверы. Когда ядро завершит настройку
и запуск своих подсистем, он первым делом запустить корневой и самый главный процесс **init().** Все процессы
запускаемые после него являются дочерними.

### Этап 4. init()

Процесс **init()** подключает директории /sys, /dev, /proc и запускает службы(daemon), которые указаны в файле **init.rc
**. Например, Service Manager, Media Server. Формат **init.rc** достаточно простой и по сути представляет собой набор
команд, разделенных на блоки. Каждый блок определяет стадию загрузки или, выражаясь языком разработчиков Android,
действие. И наконец **init()** доходит до запуска **среды выполнения Android** путем запуска службы **Zygote**.

### Этап 5. Среда выполнения Android

**Zygote** — ключевой компонент любой Android-системы, который ответственен за инициализацию, старт системных служб,
запуск и остановку пользовательских приложений и многие другие задачи. **Zygote** запускается с помощью небольшого
приложения **/system/bin/app\_process**. Задача **app\_proccess** — запустить виртуальную машину **Art/Dalvik**, код
которой располагается в разделяемой библиотекеё, а затем поверх нее запустить **Zygote**.

Когда все это будет сделано и **Zygote** получит управление, он начинает формирование среды исполнения Java-приложений с
помощью загрузки всех Java-классов фреймворка (сейчас их более 2000).

### Этап 6. system\_server

Затем **Zygote** запускает **system\_server**, включающий в себя большинство высокоуровневых (написанных на Java)
системных сервисов, в том числе **Window Manager**, **Status Bar**, **Package Manager** и, что самое важное, **Activity
Manager**, который в будущем будет ответственен за получение сигналов о старте и завершении приложений.

### Этап 7. Activity Manager

После этого **Zygote** открывает сокет **/dev/socket/zygote** и уходит в сон, ожидая данные. В это время запущенный
ранее **Activity Manager** посылает широковещательный интент **Intent.CATEGORY\_HOME**, чтобы найти *
*Launcher-приложение**, отвечающее за формирование рабочего стола, и отдает его имя **Zygote** через сокет. **Zygote**,
в свою очередь, форкается и запускает **Launcher-приложение** поверх виртуальной машины. Вуаля, у нас на экране
появляется рабочий стол, найденный **Activity Manager** и запущенный **Zygote**, и статусная строка, запущенная
system\_server в рамках службы **Status Bar**.

### Этап 8. Запуск «своего» приложения

А теперь давайте запустим свое приложение(например, Telegram), которое мы установили из Google Play Store. После тапа по
иконке искомого приложения **Launcher-приложение** пошлет интент с именем этого приложения, его примет **Activity
Manager** и передаст команду на старт приложения демону **Zygote.**

Когда **Zygote** получает запрос на старт приложения от **Activity Manager**, он не запускает новую виртуальную машину,
а просто **форкается**, то есть копирует самого себя и затем запускает поверх полученной **копии виртуальной машины**
нужное приложение.  **Копия ART/Dalvik VM**
создаёт [главный поток приложения(MainThread)](https://nurlandroid.com/?p=240).

<seealso>
  <category ref="src">
    <a href="https://developer.android.com/guide/platform">Android Developers | Platform architecture</a>
    <a href="https://nurlandroid.com/?p=321#:~:text=Zygote%20%E2%80%94%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B9%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%20%D0%BB%D1%8E%D0%B1%D0%BE%D0%B9%20Android,%2Fsystem%2Fbin%2Fapp_process">Процесс загрузки ОС Андроид - Nurlandroid</a>
  </category>
</seealso>