# Потоки

В контексте операционной системы **поток** — это фундаментальная единица исполнения, которую
диспетчеризует планировщик ОС. Потоки являются ключевым элементом операционной системы,
обеспечивающим многозадачность и эффективное использование ресурсов CPU.

Потоки позволяют выполнять несколько последовательностей инструкций одновременно внутри одного процесса.

ОС управляет созданием, планированием и завершением потоков, обеспечивая эффективное использование ресурсов.

В Android, как и в других системах на базе Linux, потоки реализованы на уровне ядра с использованием стандартных
механизмов управления и планирования.

Потоки позволяют процессу выполнять несколько последовательностей инструкций
одновременно, разделяя ресурсы процесса, такие как память и открытые дескрипторы файлов.
Они играют ключевую роль в обеспечении многозадачности и эффективного использования ресурсов CPU.

## Основные свойства

- **Поток** — это независимая последовательность выполнения инструкций внутри процесса.
- **Процесс** может содержать один или несколько потоков.
- Все потоки внутри одного процесса разделяют:
    - **Адресное пространство** процесса.
    - **Ресурсы** процесса: открытые файлы, сокеты и т.д.
- Каждый поток имеет свой собственный:
    - **Стек**: для хранения локальных переменных и контекста вызовов функций.
    - **Регистры процессора**: включая программный счетчик (PC), указатель стека (SP) и другие.
    - **Состояние выполнения**: информация, необходимая для планирования и восстановления выполнения потока.

## Работа потоков в операционной системе

1. **Создание и управление потоками**:
    - **Системные вызовы**: потоки создаются с помощью системных вызовов ОС (например, `pthread_create` в
      POSIX-системах).
    - **Идентификатор потока (TID)**: каждому потоку присваивается уникальный идентификатор для управления и
      отслеживания.
    - **Контекст потока**: включает регистры, стек и другие необходимые данные для выполнения.

2. **Планирование потоков**:
    - **Планировщик ОС**: отвечает за распределение CPU времени между потоками.
    - **Алгоритмы планирования**:
        - **Preemptive Scheduling (Вытесняющее планирование)**: ОС может приостановить выполнение текущего потока и
          переключиться на другой.
        - **Приоритеты**: потоки могут иметь различные приоритеты, влияющие на порядок их выполнения.
    - **Квант времени**: определяет максимальное время выполнения потока до его вытеснения.

3. **Состояния потока**:
    - **Running (Выполняется)**: поток активно использует CPU.
    - **Ready (Готов к выполнению)**: поток готов к выполнению, но ожидает выделения CPU.
    - **Blocked (Заблокирован)**: поток ожидает события или ресурса (например, ввода/вывода, синхронизации).
    - **Terminated (Завершен)**: поток завершил выполнение или был остановлен.

4. **Механизмы переключения контекста**:
    - **Переключение контекста (Context Switch)**: процесс сохранения состояния текущего потока и загрузки состояния
      другого.
    - **Затраты на переключение**: включает время на сохранение/восстановление регистров, переключение стека и другие
      операции.

5. **Синхронизация потоков**:
    - **Необходимость**: из-за разделения ресурсов между потоками возможны состояния гонки и конфликты при одновременном
      доступе.
    - **Механизмы синхронизации**:
        - **Мьютексы (Mutual Exclusion Locks)**: обеспечивают эксклюзивный доступ к ресурсам.
        - **Семафоры**: позволяют управлять доступом к ресурсам с учетом счетчика.
        - **Мониторы и условные переменные**: для ожидания и оповещения потоков о событиях.

### Потоки в контексте Android OS

Android основан на ядре Linux, поэтому управление потоками в Android наследует многие особенности Linux:

1. **Потоки как легковесные процессы**:
    - В Linux потоки реализованы как процессы с общим адресным пространством (используя модель `clone()`).
    - Каждый поток имеет свой `TID`, но может разделять `PID` процесса.

2. **Планирование потоков**:
    - **CFS (Completely Fair Scheduler)**: используется в современных ядрах Linux для планирования процессов и потоков.
    - **Групповое планирование**: потоки внутри одного процесса могут рассматриваться как единая группа для
      распределения ресурсов.

3. **Приоритеты и политики планирования**:
    - **Нормальные приоритеты**: для обычных потоков.
    - **Реального времени**: для потоков, требующих минимальной задержки (ограничено в Android по соображениям
      безопасности и стабильности).

4. **Ограничения и безопасность**:
    - **Контроль ресурсов**: Android ограничивает ресурсы, доступные процессам и потокам, для предотвращения
      злоупотреблений.
    - **SELinux**: используется для усиления безопасности и управления доступом потоков к системным ресурсам.

## Жизненный цикл потока

1. **Создание**:
    - Поток создается через системный вызов, определяются его начальные параметры и функция выполнения.
    - В Android нативные потоки могут создаваться с помощью API на основе POSIX (например, `pthread_create`).

2. **Выполнение**:
    - Поток начинает выполнять заданную функцию.
    - Может переходить между состояниями `Running`, `Ready` и `Blocked` в зависимости от доступа к CPU и ресурсов.

3. **Синхронизация и взаимодействие**:
    - Потоки могут взаимодействовать друг с другом через разделяемую память и синхронизирующие примитивы.
    - Важно корректно управлять доступом к общим данным для предотвращения ошибок.

4. **Завершение**:
    - Поток может завершиться естественно после выполнения своей функции.
    - Может быть принудительно завершен другими потоками (не рекомендуется из-за риска утечек ресурсов).

## Планирование потоков в операционной системе

- **Алгоритмы планирования**:
    - **Round Robin**: потоки получают равные кванты времени по очереди.
    - **Приоритетное планирование**: потоки с более высоким приоритетом получают больше CPU времени.
    - **Многоуровневые очереди**: комбинация различных стратегий для разных классов потоков.

- **Факторы, влияющие на планирование**:
    - **Приоритет потока**.
    - **Интерактивность**: потоки, связанные с пользовательским интерфейсом, могут получать предпочтение.
    - **История использования CPU**: потоки, долго не использовавшие CPU, могут получить приоритет.

- **Вывод**: ОС стремится эффективно использовать CPU, балансируя между справедливостью и приоритетами потоков.

## Ресурсы и изоляция потоков

- **Разделяемые ресурсы**:
    - Потоки внутри процесса имеют доступ к общей куче, глобальным переменным и дескрипторам файлов.
    - Это облегчает межпоточное взаимодействие, но требует осторожности при доступе к общим данным.

- **Изоляция**:
    - Стек каждого потока изолирован, предотвращая случайное изменение локальных переменных других потоков.
    - Регистры и контекст выполнения также индивидуальны для каждого потока.

## Синхронизация и конкурентность

- **Проблемы конкурентности**:
    - **Состояния гонки**: возникают, когда несколько потоков одновременно обращаются к одним и тем же данным.
    - **Дедлоки**: ситуации, когда потоки навсегда заблокированы, ожидая ресурсы друг от друга.

- **Механизмы предотвращения**:
    - **Блокировки и мьютексы**: обеспечивают эксклюзивный доступ к ресурсам.
    - **Условные переменные**: позволяют потокам ждать определенных условий.
    - **Барьеры**: синхронизируют выполнение групп потоков.

## Ограничения и оптимизация

- **Ограничения на количество потоков**:
    - **Аппаратные**: количество ядер CPU определяет степень параллелизма.
    - **Память**: каждый поток потребляет память для стека и контекста.
    - **Ограничения ОС**: максимальное количество потоков может быть ограничено системными параметрами.

- **Оптимизация использования потоков**:
    - **Минимизация переключений контекста**: уменьшает накладные расходы на планирование.
    - **Использование многопоточности там, где это необходимо**: избыточное количество потоков может снизить
      производительность.
    - **Балансировка нагрузки**: равномерное распределение задач между потоками.

## Потоки ядра и пользовательские потоки

- **Потоки ядра (Kernel Threads)**:
    - Управляются непосредственно ядром ОС.
    - Используются для выполнения системных задач.

- **Пользовательские потоки (User Threads)**:
    - Управляются библиотеками в пространстве пользователя.
    - Могут быть сопоставлены с потоками ядра через модели:
        - **Один-к-одному (1:1)**: каждый пользовательский поток соответствует потоку ядра.
        - **Многие-к-одному (M:1)**: несколько пользовательских потоков отображаются на один поток ядра.
        - **Многие-ко-многим (M:N)**: гибкое сопоставление потоков.

- **В Android**:
    - Используется модель **1:1**, где каждый пользовательский поток соответствует потоку ядра.

## Безопасность и стабильность

- **Изоляция процессов**:
    - Потоки не могут напрямую взаимодействовать с потоками других процессов.
    - Это обеспечивает безопасность и стабильность системы.

- **Ограничения привилегий**:
    - Потоки наследуют привилегии процесса.
    - Доступ к критическим ресурсам контролируется ОС.